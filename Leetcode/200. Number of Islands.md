**Question :**

Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

**Input:** grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
**Output:** 1

**Example 2:**

**Input:** grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
**Output:** 3

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` is `'0'` or `'1'`.

**Solution:**

```java
class Solution {
    boolean visited[][];

    public int numIslands(char[][] grid) {
        visited = new boolean[grid.length][grid[0].length];
        int islands = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    bfs(i, j, grid);
                    islands++;
                }
            }
        }
        return islands;
    }

    void bfs(int i, int j, char[][] grid) {
        int arr[][] = {
                { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 }
        };
        Queue<int[]> q = new LinkedList<>();
        visited[i][j] = true;
        q.add(new int[] { i, j });
        while (!q.isEmpty()) {
            int cur[] = q.poll();
            int r = cur[0], c = cur[1];
            for (int idx[] : arr) {
                int ic = r + idx[0];
                int jc = c + idx[1];
                if (ic >= 0 && jc >= 0 && ic < grid.length &&
                        jc < grid[0].length &&
                        !visited[ic][jc] && grid[ic][jc] == '1') {
                    q.add(new int[] { ic, jc });
                    visited[ic][jc] = true;
                }

            }
        }
    }
}
```


