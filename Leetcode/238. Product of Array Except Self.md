
**Question:**

Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.

The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

You must write an algorithm that runs inÂ `O(n)`Â time and without using the division operation.

**Example 1:**

> **Input:** nums = [1,2,3,4]  
> **Output:** [24,12,8,6]

**Example 2:**

> **Input:** nums = [-1,1,0,-3,3]  
> **Output:** [0,0,9,0,0]

**Constraints:**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- The input is generated such that `answer[i]` is **guaranteed** to fit in a **32-bit** integer.

My Approach : 

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int prod = 1;
        boolean zero = false , twoZeros = false;
        int res[] = new int[nums.length];

        for (int num : nums) {
            if (num == 0){
                if(zero) twoZeros = true;
                zero = true; 
            }
            else
                prod *= num;
        }

        if(twoZeros) return new int[nums.length];

        for (int i = 0; i < nums.length; i++) {
            if (!zero)
                res[i] = prod / nums[i];
            else {
                if (nums[i] == 0)
                    res[i] = prod;
                else
                    res[i] = 0;
            }
        }
        return res;
    }
}
```


Optimal Solution:
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];

        res[0] = 1;
        for(int i = 1; i < n; i++){
            res[i] = res[i-1] * nums[i-1];
        }

        int suff = 1;
        for(int i = n - 1; i >= 0; i--){
            res[i] *= suff;
            suff *= nums[i];
        }

        return res;
    }
}
```