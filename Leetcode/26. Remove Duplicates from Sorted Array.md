
**Question:**

Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears only **once**. The **relative order** of the elements should be kept the **same**.Consider the number of _unique elements_ in `nums` to be `k​​`​​​​​​​. After removing duplicates, return the number of unique elements `k`. The first `k` elements of `nums` should contain the unique numbers in **sorted order**. The remaining elements beyond index `k - 1` can be ignored.

**Example 1:**

> **Input:** nums = [1,1,2] <br>
> **Output:** 2, nums = [1,2,_] <br>
> **Explanation:** Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively . <br>
> It does not matter what you leave beyond the returned k (hence they are underscores).

**Example 2:**

> **Input:** nums = [0,0,1,1,1,2,2,3,3,4] <br>
> **Output:** 5, nums = [0,1,2,3,4,_,_,_,_,_]<br>
> **Explanation:** Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. <br>
> It does not matter what you leave beyond the returned k (hence they are underscores).

**Constraints:**

- `1 <= nums.length <= 3 * 104`
- `-100 <= nums[i] <= 100`
- `nums` is sorted in **non-decreasing** order.

**My First Approach :**
```java
 class Solution {
    public int removeDuplicates(int[] nums) {
        int res = 1;

        //replace the repeated number with -1 and count res
        for(int i=0;i<nums.length-1;i++){
            if(nums[i]==nums[i+1]) nums[i] = -101;
            else res++;
        }
        
        //sort it linearly using two pointer
        int r = 0 , l = 0 ;
        while(l<nums.length){
            while(l<nums.length && nums[l]==-101) l++;
            if(l<nums.length) nums[r] = nums[l];
            r++; l++;
        }

        return res;
    }
}
```

**Wrong doing here :**
- Using -101
- Two loops
- overcomplicated logic

**Optimal Solution**

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;
        int k = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[k] = nums[i];
                k++;
            }
        }

        return k;
    }
}
```