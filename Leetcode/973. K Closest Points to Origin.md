
**Question:**

Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.

The distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `âˆš(x1 - x2)2 + (y1 - y2)2`).

You may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)

**Input:** points = [[1,3],[-2,2]], k = 1
**Output:** [[-2,2]]
**Explanation:**
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].

**Example 2:**

**Input:** points = [[3,3],[5,-1],[-2,4]], k = 2
**Output:** [[3,3],[-2,4]]
**Explanation:** The answer [[-2,4],[3,3]] would also be accepted.

**Constraints:**

- `1 <= k <= points.length <= 104`
- `-104 <= xi, yi <= 104`
  
**My approach:**

```java
class Solution {
    public int[][] kClosest(int[][] points, int k) {
        int res [][] = new int [k][2];
        PriorityQueue<Double> heap = new PriorityQueue<>();
        boolean seen [] = new boolean[points.length];
        for(int point[]:points){
            double val = Math.sqrt(point[1]*point[1]+point[0]*point[0]);
            heap.add(val);
        }
        int count = 0;
        while(count<k){
            double val = heap.poll();
            for(int i=0;i<points.length;i++){
                int [] point = points[i];
                double valc = Math.sqrt(point[1]*point[1]+point[0]*point[0]);
                if(val == valc && !seen[i]){
                    res[count] = point;
                    seen[i] = true;
                    count++;
                    break;
                }
            }
        }
        return res;
    }
}
```


**Optimal Approaches:**

*Sorting*

```java
class Solution {
    public int[][] kClosest(int[][] points, int k) {
        Arrays.sort(points, (a, b) -> Integer.compare((a[0] * a[0] + a[1] * a[1]),
                                      (b[0] * b[0] + b[1] * b[1])));
        return Arrays.copyOfRange(points, 0, k);
    }
}
```


*Min-Heap*

```java
public class Solution {
    public int[][] kClosest(int[][] points, int K) {
        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparing(a -> a[0]));
        for (int[] point : points) {
            int dist = point[0] * point[0] + point[1] * point[1];
            minHeap.offer(new int[]{dist, point[0], point[1]});
        }

        int[][] result = new int[K][2];
        for (int i = 0; i < K; ++i) {
            int[] point = minHeap.poll();
            result[i] = new int[]{point[1], point[2]};
        }
        return result;
    }
}
```
